# Написать свой cache декоратор c максимальным размером кеша и его очисткой при необходимости.
# Декоратор должен перехватывать аргументы оборачиваемой функции
# Декоратор должен иметь хранилище, где будут сохраняться все перехваченные аргументы и результаты выполнения декорируемой функции
# Декоратор должен проверять наличие перехваченных аргументов в хранилище. Если декорируемая функция уже вызывалась с такими аргументами, она не будет вызываться снова, вместо этого декоратор вернет сохраненное значение.
# Декоратор должен принимать один аргумент - максимальный размер хранилища.
# Если хранилище заполнено, нужно удалить 1 любой элемент, чтобы освободить место под новый.

cash = dict()

def do_cache(maxsize):
    def decorator(func):
        def wrapper(*kwargs):

            key = f"{a}_{b}"
            result = cash.get(key, None)
            if not result:
                result = func(a, b)
                if len(cash.keys()) >= maxsize:
                    for i in cash:
                        cash.pop(i)
                        break
                cash.update({key:result})

        return wrapper
    return decorator


@do_cache(maxsize=3)
def get_value(a, b):
  return a ** b

a = 4
b = 5
get_value(a, b)

print(cash)